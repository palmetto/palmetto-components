import { useState } from 'react';
import { action } from '@storybook/addon-actions';
import { Meta, Story, Canvas, ArgsTable } from '@storybook/addon-docs/blocks';
import { ToastContainer, toast } from './';
import { Box } from '../Box/Box';
import { Button } from '../Button/Button';

<Meta
  title="Components/Toast/Overview"
  component={ToastContainer}
  parameters={{
    controls: { hideNoControlsWarning: true },
  }}
  decorators={[storyFn => (
    <div>
      <ToastContainer />
      {storyFn()}
    </div>
  )]}
/>

# Toast

Use a toast to communicate non-critical information or feedback to a user about the result of an action.
Typically you'd reserve toasts for non-essential notifications, since they are meant to disappear automatically
under normal circumstances.

You might use a toast to tell a user whether an interaction on the page was successful.

## Usage Guidelines
1. For errors, prefer persisted Alerts over Toasts. See [Alert](?path=/docs/components-alert-overview--default-story).
2. Keep messages short. Typically if a toast results in a multiline message, that is a queue that it is likely too long.
3. Try to avoid adding actions inside of a toast. If you include an action (other than dismiss) in a toast,
try and have that action available somewhere else on the page.
E.G: a `retry` action can also be triggered by re-submitting a form.
4. The main exception that makes for a useful toast action is an `undo` button, which is unlikely to make sense
in most pages, but is a great escape hatch for a user that wants to take back an action.
5. DO NOT use a toast as a blocking alert or interstitial (I.E: to restrict or contextualize user actions). In these
cases, use a [Modal](?path=/docs/components-modal-overview--default-story).

## Content Guidelines

Keep the contents of a toast as short as possible by placing only the most important information in it. Toasts are meant to unobtrusively provide feedback for non-critical information or feedback. In general, toast messages should be:

- short and affirmative
- Written in a pattern of noun + verb, such as "Proposal saved" or "hic_contract.pdf added".

<Canvas isExpanded>
  <Story name="Default">
    {() => {
      const handleClick = () => toast('Proposal saved!', { duration: 30000 });
      return (
        <>
          <Button onClick={handleClick}>
            Click to see toast
          </Button>
        </>
      );
    }}
  </Story>
</Canvas>

## Required Setup

1. Include the `<ToastContainer />` in your React app. (at the highest possible level of the DOM tree);
2. Create a toast anywhere in your app `toast('hello!')`.

**NOTE:** All examples of this page exclusively showcase step 2 above, as the ToastContainer is added globally on the page.

### Example
```jsx
// App.jsx
import { ToastContainer } from '@palmetto/palmetto-components';

export const App = () => {
  <MyAppContainer>
    <ToastContainer {/* custom props */} />
    {/* Routes, other providers, etc */}
  </MyAppContainer>
};

// SomeAppPage.jsx
import { toast } from '@palmetto/palmetto-components';

export const SomeAppPage = () => {
  <button onClick={() => toast('hello!')}>
    gimme a toast
  </button>
}
```

## Props (for `<ToastContainer />`)

<ArgsTable of={ToastContainer} />

<Canvas isExpanded>
  <Story name="Position">
    {() => {
      const handleClick = position => toast('hey oh!', { position });
      return (
        <>
          <Box childGap="md" direction="row">
            <Button onClick={() => handleClick('top-right')}>
              top right
            </Button>
            <Button onClick={() => handleClick('top-center')}>
              top center
            </Button>
            <Button onClick={() => handleClick('topleft')}>
              top left
            </Button>
            <Button onClick={() => handleClick('bottom-right')}>
              bottom right
            </Button>
            <Button onClick={() => handleClick('bottom-center')}>
              bottom center
            </Button>
            <Button onClick={() => handleClick('bottom-left')}>
              bottom left
            </Button>
          </Box>
        </>
      );
    }}
  </Story>
</Canvas>

### Duration

We've included sensible defaults for the duration of a toast before it disappears, but if you require custom duration, follow these guidelines:

1. Error toasts should likely stay on the screen
longer than success toasts, since they are arguably more important.
2. Toasts with actions, should stay on screen for at least 10 seconds.
3. async toasts with loading states should always included success and failure conditions,
to avoid an infinite spinner.

<Canvas isExpanded>
  <Story name="Duration">
    {() => {
      const handleClick = () => {
        toast(`toast will close in 6 seconds`, { duration: 6000 });
      };
      return (
        <>
          <Box childGap="md" direction="row">
            <Button onClick={handleClick}>
              Open toast with custom duration
            </Button>
          </Box>
        </>
      );
    }}
  </Story>
</Canvas>

### Dismissible (or lack thereof)

By default, all Toasts are dismissible since they
should not hinder the user experience, but we still wish to provide a quick and easy
escape hatch, should a user want to clear it out of their view.

In cases where you'd like the toast to remain for a set amount of time
without the user being able to clear it, you can use `canDismiss: false`.

<Canvas isExpanded>
  <Story name="Dismissible">
    {() => {
      const handleClick = () => {
        toast(`this toast can't be dismissed`, { canDismiss: false, duration: 100000 });
      };
      return (
        <>
          <Box childGap="md" direction="row">
            <Button onClick={handleClick}>
              Open non-dismissible toast
            </Button>
          </Box>
        </>
      );
    }}
  </Story>
</Canvas>

### Compact

Use the `isCompact` prop for a toast the uses less screen real estate.

<Canvas isExpanded>
  <Story name="Compact">
    {() => {
      const handleClick = () => {
        toast('This is compact', { isCompact: true });
      };
      return (
        <>
          <Box childGap="md" direction="row">
            <Button onClick={handleClick}>
              Open compact toast
            </Button>
          </Box>
        </>
      );
    }}
  </Story>
</Canvas>

### Toast Types

<Canvas isExpanded>
  <Story name="Basic Types">
    {() => {
      const handleClick = (type) => {
        if (type === 'success') {
          const successToastId = toast.success('Proposal saved');
        } else if (type === 'error') {
          toast.error('Unable to save');
        } else if (type === 'loading') {
          const toastId = toast.loading('Loading...', { duration: 10000, canDismiss: false });
        } else {
          toast('Toast without icon');
        }
      };
      return (
        <>
          <Box fontSize="lg" fontWeight="bold" margin="0 0 md 0">
            Basic Types
          </Box>
          <Box childGap="md" direction="row">
            <Button onClick={() => handleClick('blank')} variant="light">
              blank
            </Button>
            <Button onClick={() => handleClick('error')} variant="danger">
              error
            </Button>
            <Button onClick={() => handleClick('success')} variant="success">
              success
            </Button>
            <Button onClick={() => handleClick('loading')} variant="dark">
              loading
            </Button>
          </Box>
        </>
      );
    }}
  </Story>
</Canvas>

<Canvas isExpanded>
  <Story name="Advanced Types">
    {() => {
      const handleClick = (type) => {
        if (type.includes('async')) {
          const promise = new Promise((resolve, reject) => {
            const randomNum = Math.floor(Math.random() * 2)
            setTimeout(() => {
              if (randomNum % 2 === 0) {
                resolve('this is your data');
              } else {
                reject('bad request!');
              }
            }, 2000);
          });
          toast.async(promise, {
            loading: 'loading',
            success: (data) => `success! ${type.includes('data') ? data : ''}`,
            error: (err) => `error! ${type.includes('data') ? err : ''}`,
          });
        }
      };
      return (
        <>
          <Box fontSize="lg" fontWeight="bold" margin="0 0 md 0">
            Advanced Types
          </Box>
          <Box display="block" childGap="md">
            <Box display="block" childGap="sm">
              <p>
                With an async toast, you can pass the three states of an async op (loading, success, error)
                to a corresponding toast state. By passing the promise itself to the
                toast component, will will handle displaying different toast variations based on the
                state of the passed promise.
              </p>
              <Button onClick={() => handleClick('async')} variant="light">
                async
              </Button>
            </Box>
            <Box display="block" childGap="sm">
              <p>
                If you need to include data or an error returned from the promise
                you can pass a function to the toasts in question, see code example.
              </p>
              <Button onClick={() => handleClick('async-data')} variant="light">
                async (including promise data)
              </Button>
            </Box>
          </Box>
        </>
      );
    }}
  </Story>
</Canvas>
