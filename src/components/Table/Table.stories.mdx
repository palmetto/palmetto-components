import { useState, useEffect } from 'react';
import { action } from '@storybook/addon-actions';
import { Meta, Story, Canvas, ArgsTable } from '@storybook/addon-docs/blocks';
import Button from '../Button/Button';
import Table from './Table';

<Meta
  title="Components/Table"
  component={Table}
/>

# Table

Use tables to render datasets.

Tables display information in a way thatâ€™s easy to scan, while making it easy to interact with individual records in a data set.

Lastly use tables when you need the ability to sort, filter and/or paginate data.

## Props

<ArgsTable of={Table} />

## Column
The column object allows you to configure each table column header as well as some aspects about its underlying cells.
You will pass an array of columns to your table, where each column is an object with the following properties.
NOTE: all properties in a column object are optional, but we highly recommend including a `heading` in every column.

<Canvas>
  <Story name="Column">
    {() => {
      const codePreviewStyle = {
        padding: '3px 5px',
        borderRadius: '3px',
        border: '1px solid #EEEEEE',
        color: 'rgba(51,51,51,0.9)',
        backgroundColor: '#F8F8F8',
      };
      const columnInterfaceRows = [
        { name: 'align', type: 'left | right | center', description: 'Text alignment for column cells (including header alignment). Cells will default to left if not defined.' },
        { name: 'cellClassName', type: 'string', description: 'A CSS class to be applied to all cells in the column' },
        { name: 'dataKey', type: 'string', description: 'The key in the rows object that matches this column' },
        { name: 'emptyCellPlaceholder', type: 'string | number | undefined', description: 'placeholder for empty cells' },
        { name: 'heading', type: 'string', description: 'The heading text to be displayed' },
        { name: 'headerClassName', type: 'string', description: 'The CSS class to be applied to the column header cell.' },
        { name: 'isSortable', type: 'boolean', description: 'Whether the column is sortable. Controls displaying the sort arrows and making the column header clickable' },
        { name: 'key', type: 'React.Key', description: 'a custom key to be passed to each column. This gets autogenerated if not supplued' },
        { name: 'render', type: 'function: (cell, row, rowIndex) => ReactNode', description: 'Render any custom content based on the cell and row content'},
        { name: 'truncateOverflow', type: 'boolean', description: 'Whether the column content will get truncated (with ellipsis) if it surpasses the fixed-width' },
        { name: 'width', type: 'number', description: 'Specify the width of a particular column.'},
      ];
      const columnConfig = [
        { heading: 'Name', dataKey: 'name' },
        { heading: 'Type', dataKey: 'type', render: (cell) => <code style={codePreviewStyle}>{cell}</code> },
        { heading: 'Description', dataKey: 'description' },
      ];
      return (
        <Table
          rowKey="name"
          columns={columnConfig}
          rows={columnInterfaceRows}
        />
      );
    }}
  </Story>
</Canvas>

## Common Example
An example showcasing the props required to render a list of customers in a table. `rows` and `columns`.

<Canvas>
  <Story name="Default">
    {() => {
      const columnConfig = [
        { heading: 'Customer',
          dataKey: 'customerInfo',
          render: (cell, row) => (
            <div>
              <div>{row.name}</div>
              <div className="font-color-grey">{row.email}</div>
            </div>
          ),
        },
        { heading: 'phone', dataKey: 'phone', width: 125 },
        { heading: 'plan', dataKey: 'plan', width: 125 },
        { heading: 'status', dataKey: 'status', width: 125 },
      ];
      const tableData = [
        { status: 'lead captured',
          name: 'John Smith',
          email: 'john@palmetto.com',
          phone: '555 555-5555',
          plan: 'standard'
        },
        { status: 'proposal in progress',
          name: 'Jill Sanchez',
          email: 'jill@palmetto.com',
          phone: '555 555-5555',
          plan: 'premium'
        },
        { status: 'PTO',
          name: 'Jin Lee',
          email: 'jin@palmetto.com',
          phone: '555 555-5555',
        plan: 'standard'
        },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
        />
      );
    }}
  </Story>
</Canvas>

## Loading

Use the `isLoading` prop on the `<Table />` component to display an overlay that prevents user interaction. Useful for when
table data is being fetched or refreshed.

<Canvas>
  <Story name="Loading">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color' },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          isLoading
        />
      );
    }}
  </Story>
</Canvas>


## Sortable
Make table columns sortable by passing the `isSortable` prop as part of the `Column` that you'd like to sort.
Sorting is completely controlled outside of our library. The table will fire an `onSort` callback when a column is sorted,
which bubbles up the click or keyboard event, along with a `sortedKey` value. The `sortedKey` refers to the `dataKey` of the column
that was sorted. E.G: if user clicks to sort the `color` column, then `sortedKey = 'color'` in the sort event.

While sorting happens fully outside of the library, meaning that the Table expects sorted data to be passed correctly to it,
It does expect to know if a column is sorted so that it can update the UI accordingly. If you pass sorted data to the table,
include the `sortedColumn` prop which comprises the following attributes:

`dataKey: string mathching the column key,`

`sortDirection: oneOf: 'none', 'ascending', 'descending'`

<Canvas>
  <Story name="Sortable">
    {() => {
      const sortDescending = (arrOfObj, key) => [...arrOfObj].sort((a, b) => (b[key] > a[key]) ? 1 : -1);
      const sortAscending = (arrOfObj, key) => [...arrOfObj].sort((a, b) => (a[key] > b[key]) ? 1 : -1);
      const getNewSortDirection = (event, currentSortedColumn) => {
        if (
          event.sortedKey === currentSortedColumn.dataKey
          && currentSortedColumn.sortDirection === 'ascending'
        ) return 'descending';
        return 'ascending';
      };
      const initialData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'green', flavor: 'strawberry' },
        { id: 3, color: 'blue', flavor: 'chocolate' },
      ];
      const [sortedColumn, setSortedColumn] = useState({});
      const [tableData, setTableData] = useState(initialData);
      const handleSort = event => {
        const newSortDirection = getNewSortDirection(event, sortedColumn);
        setSortedColumn({
          dataKey: event.sortedKey,
          sortDirection: newSortDirection,
        });
      };
      useEffect(() => {
        if (sortedColumn.dataKey && sortedColumn.sortDirection) {
          const sortedData =
            sortedColumn.sortDirection === 'ascending'
            ? sortAscending(tableData, sortedColumn.dataKey)
            : sortDescending(tableData, sortedColumn.dataKey);
          setTableData(sortedData);
        }
      }, [sortedColumn]);
      const columnConfig = [
        { heading: 'ID', dataKey: 'id', isSortable: true },
        { heading: 'Color', dataKey: 'color', isSortable: true },
        { heading: 'Flavor', dataKey: 'flavor', isSortable: true },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          sortedColumn={sortedColumn}
          onSort={handleSort}
        />
      );
    }}
  </Story>
</Canvas>


## Sortable with Default Sorted Column

Having a column be sorted by default is no different than sorting a column, we pass the `sortedColumn` object as a prop on initial
render rather than only populating it upon user interaction.

<Canvas>
  <Story name="Sortable with Default Sorted Column">
    {() => {
      const sortDescending = (arrOfObj, key) => [...arrOfObj].sort((a, b) => (b[key] > a[key]) ? 1 : -1);
      const sortAscending = (arrOfObj, key) => [...arrOfObj].sort((a, b) => (a[key] > b[key]) ? 1 : -1);
      const getNewSortDirection = (event, currentSortedColumn) => {
        if (
          event.sortedKey === currentSortedColumn.dataKey
          && currentSortedColumn.sortDirection === 'ascending'
        ) return 'descending';
        return 'ascending';
      };
      const initialData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'green', flavor: 'strawberry' },
        { id: 3, color: 'blue', flavor: 'chocolate' },
      ];
      const [sortedColumn, setSortedColumn] = useState({ dataKey: 'color', sortDirection: 'descending' });
      const [tableData, setTableData] = useState([
        ...sortedColumn.sortDirecton === 'ascending'
        ? sortAscending(initialData, sortedColumn.dataKey)
        : sortDescending(initialData, sortedColumn.dataKey)
      ]);
      const handleSort = event => {
        const newSortDirection = getNewSortDirection(event, sortedColumn);
        setSortedColumn({
          dataKey: event.sortedKey,
          sortDirection: newSortDirection,
        });
      };
      useEffect(() => {
        if (sortedColumn.dataKey && sortedColumn.sortDirection) {
          const sortedData =
            sortedColumn.sortDirection === 'ascending'
            ? sortAscending(tableData, sortedColumn.dataKey)
            : sortDescending(tableData, sortedColumn.dataKey);
          setTableData(sortedData);
        }
      }, [sortedColumn]);
      const columnConfig = [
        { heading: 'ID', dataKey: 'id', isSortable: true },
        { heading: 'Color', dataKey: 'color', isSortable: true },
        { heading: 'Flavor', dataKey: 'flavor', isSortable: true },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          sortedColumn={sortedColumn}
          onSort={handleSort}
        />
      );
    }}
  </Story>
</Canvas>


## Sortable and Loading

Setting the `isLoading` prop to true will disable clicking on the column headers. This prevents a race condition where an attempt to sort is made before data from the previous load is available.

<Canvas>
  <Story name="Sortable and Loading">
    {() => {
      const sortDescending = (arrOfObj, key) => [...arrOfObj].sort((a, b) => (b[key] > a[key]) ? 1 : -1);
      const sortAscending = (arrOfObj, key) => [...arrOfObj].sort((a, b) => (a[key] > b[key]) ? 1 : -1);
      const getNewSortDirection = (event, currentSortedColumn) => {
        if (
          event.sortedKey === currentSortedColumn.dataKey
          && currentSortedColumn.sortDirection === 'ascending'
        ) return 'descending';
        return 'ascending';
      };
      const initialData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'green', flavor: 'strawberry' },
        { id: 3, color: 'blue', flavor: 'chocolate' },
      ];
      const [sortedColumn, setSortedColumn] = useState({});
      const [tableData, setTableData] = useState(initialData);
      const handleSort = event => {
        const newSortDirection = getNewSortDirection(event, sortedColumn);
        setSortedColumn({
          dataKey: event.sortedKey,
          sortDirection: newSortDirection,
        });
      };
      useEffect(() => {
        if (sortedColumn.dataKey && sortedColumn.sortDirection) {
          const sortedData =
            sortedColumn.sortDirection === 'ascending'
            ? sortAscending(tableData, sortedColumn.dataKey)
            : sortDescending(tableData, sortedColumn.dataKey);
          setTableData(sortedData);
        }
      }, [sortedColumn])
      const columnConfig = [
        { heading: 'ID', dataKey: 'id', isSortable: true },
        { heading: 'Color', dataKey: 'color', isSortable: true },
        { heading: 'Flavor', dataKey: 'flavor', isSortable: true },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          sortedColumn={sortedColumn}
          onSort={handleSort}
          isLoading
        />
      );
    }}
  </Story>
</Canvas>

## Scrollable

If you wish to lock your table into a particular `width` or `height` but render it fully (introducing scrolling) use the
`scroll` prop. It is an object with the keys:

`x: boolean,`

`y: boolean`.

Given this prop, the table will scroll horizontally, or verically basde on the width of its parent container.
Note, the table will use the standard `auto` HTML algorithm for sizing columns based on their content, unless a column
is given a specific width. In the example below we've made the table fit in a parent container that is 300x300 pixels
with the second column having a fixed width of 300 pixels.

<Canvas>
  <Story name="Scrollable">
    {() => {
      const containerStyle = {
        padding: '3px 5px',
        borderRadius: '3px',
        border: '1px solid #EEEEEE',
        width: '300px',
        height: '300px',
      };
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color', width: 300 },
        { heading: 'Flavor', dataKey: 'flavor' },
        { heading: 'Brightness', dataKey: 'brightness' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla', brightness: 'light' },
        { id: 2, color: 'blue', flavor: 'chocolate', brightness: 'medium' },
        { id: 3, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 4, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 5, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 6, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 7, color: 'green', flavor: 'strawberry', brightness: 'dark' },
      ];
      return (
        <div style={containerStyle}>
          <Table
            rowKey="id"
            columns={columnConfig}
            rows={tableData}
            isScrollable={{ x: true, y: true }}
          />
        </div>
      );
    }}
  </Story>
</Canvas>

## Scrollable with Sticky Header

<Canvas>
  <Story name="Scrollable with Sticky Header">
    {() => {
      const containerStyle = {
        borderRadius: '3px',
        border: '1px solid #EEEEEE',
        width: '300px',
        height: '300px',
      };
      const columnConfig = [
        { heading: 'ID', dataKey: 'id'},
        { heading: 'Color', dataKey: 'color', width: 300 },
        { heading: 'Flavor', dataKey: 'flavor', width: 100 },
        { heading: 'Brightness', dataKey: 'brightness', width: 150 },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla', brightness: 'light' },
        { id: 2, color: 'blue', flavor: 'chocolate', brightness: 'medium' },
        { id: 3, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 4, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 5, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 6, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 7, color: 'green', flavor: 'strawberry', brightness: 'dark' },
      ];
      return (
        <div style={containerStyle}>
          <Table
            rowKey="id"
            columns={columnConfig}
            rows={tableData}
            scr
            isScrollable={{ x: true, y: true }}
            isHeaderSticky
          />
        </div>
      );
    }}
  </Story>
</Canvas>

## Scrollable with Sticky First Column

<Canvas>
  <Story name="Scrollable with Sticky First Column">
    {() => {
      const containerStyle = {
        borderRadius: '3px',
        border: '1px solid #EEEEEE',
        width: '300px',
        height: '300px',
      };
      const columnConfig = [
        { heading: 'ID', dataKey: 'id', sticky: true },
        { heading: 'Color', dataKey: 'color', width: 300 },
        { heading: 'Flavor', dataKey: 'flavor', width: 100 },
        { heading: 'Brightness', dataKey: 'brightness', width: 150 },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla', brightness: 'light' },
        { id: 2, color: 'blue', flavor: 'chocolate', brightness: 'medium' },
        { id: 3, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 4, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 5, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 6, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 7, color: 'green', flavor: 'strawberry', brightness: 'dark' },
      ];
      return (
        <div style={containerStyle}>
          <Table
            rowKey="id"
            columns={columnConfig}
            rows={tableData}
            scr
            isScrollable={{ x: true, y: true }}
          />
        </div>
      );
    }}
  </Story>
</Canvas>

## Scrollable with Sticky Header and First Column

<Canvas>
  <Story name="Scrollable with Sticky Header and First Column">
    {() => {
      const containerStyle = {
        borderRadius: '3px',
        border: '1px solid #EEEEEE',
        width: '300px',
        height: '300px',
      };
      const columnConfig = [
        { heading: 'ID', dataKey: 'id', sticky: true },
        { heading: 'Color', dataKey: 'color', width: 300 },
        { heading: 'Flavor', dataKey: 'flavor', width: 100 },
        { heading: 'Brightness', dataKey: 'brightness', width: 150 },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla', brightness: 'light' },
        { id: 2, color: 'blue', flavor: 'chocolate', brightness: 'medium' },
        { id: 3, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 4, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 5, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 6, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 7, color: 'green', flavor: 'strawberry', brightness: 'dark' },
      ];
      return (
        <div style={containerStyle}>
          <Table
            rowKey="id"
            columns={columnConfig}
            rows={tableData}
            scr
            isScrollable={{ x: true, y: true }}
            isHeaderSticky
          />
        </div>
      );
    }}
  </Story>
</Canvas>

## Scrollable with Sticky Header and Nth Column

<Canvas>
  <Story name="Scrollable with Sticky Header and Nth Column">
    {() => {
      const containerStyle = {
        borderRadius: '3px',
        border: '1px solid #EEEEEE',
        width: '300px',
        height: '300px',
      };
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color', width: 50, sticky: true },
        { heading: 'Flavor', dataKey: 'flavor', width: 100 },
        { heading: 'Brightness', dataKey: 'brightness', width: 400 },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla', brightness: 'light' },
        { id: 2, color: 'blue', flavor: 'chocolate', brightness: 'medium' },
        { id: 3, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 4, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 5, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 6, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 7, color: 'green', flavor: 'strawberry', brightness: 'dark' },
      ];
      return (
        <div style={containerStyle}>
          <Table
            rowKey="id"
            columns={columnConfig}
            rows={tableData}
            scr
            isScrollable={{ x: true, y: true }}
            isHeaderSticky
          />
        </div>
      );
    }}
  </Story>
</Canvas>

## Scrollable and Loading

All interactions, including clicking and scrolling will be disabled when a scrollable table is loading.

<Canvas>
  <Story name="Scrollable and Loading">
    {() => {
      const containerStyle = {
        padding: '3px 5px',
        borderRadius: '3px',
        border: '1px solid #EEEEEE',
        width: '300px',
        height: '300px',
      };
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color', width: 300 },
        { heading: 'Flavor', dataKey: 'flavor' },
        { heading: 'Brightness', dataKey: 'brightness' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla', brightness: 'light' },
        { id: 2, color: 'blue', flavor: 'chocolate', brightness: 'medium' },
        { id: 3, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 4, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 5, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 6, color: 'green', flavor: 'strawberry', brightness: 'dark' },
        { id: 7, color: 'green', flavor: 'strawberry', brightness: 'dark' },
      ];
      return (
        <div style={containerStyle}>
          <Table
            rowKey="id"
            columns={columnConfig}
            rows={tableData}
            isScrollable={{ x: true, y: true }}
            isLoading
          />
        </div>
      );
    }}
  </Story>
</Canvas>


## Fixed-Width Columns

If you wish to lock the width of a particular column set the actual column `width` in your column object. Widths are set independently for each column.

<Canvas>
  <Story name="Fixed-Width Columns">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id', width: 150 },
        { heading: 'Color', dataKey: 'color' },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
        />
      );
    }}
  </Story>
</Canvas>

## Fixed Table Layout

The default layout algorithm for a HTML table is `auto`. Use the `useFixedTableLayout` prop to set the table's layout algorithm to `fixed`.

<Canvas>
  <Story name="Fixed Table Layout">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id', width: 150 },
        { heading: 'Color', dataKey: 'color' },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          useFixedTableLayout 
        />
      );
    }}
  </Story>
</Canvas>


## Truncate Overflow

In cases where long text content is expected but displaying it fully isn't required, use the `truncateOverflow` prop on the table.
This will truncate column content, but only if a fixed width is passed to that column. NOTE: the `truncateOverflow` exists
in the `Column` object as well, making it possible to set it globally on the table or individually on a column. The column
value will supersede the global setting.

<Canvas>
  <Story name="Truncate Overflow">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color', width: 100 },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue longy long long long', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          truncateOverflow
        />
      );
    }}
  </Story>
</Canvas>


## Custom Actions

The `Column` object is equiped with a `render` method. When used, the cells will render any custom JSX returned by this method. This can be used in a completely agnostic way. See `Any custom JSX` column below, where we render the same markup regardless of the cell/row content.

The render method also exposes data about the cell and row, namely:

`cell: the content in the cell,`

`row: the entire row object,`

`rowIndex: the index of the row in the table`


With this data in the render function it is possible to render complex elements inside of a single cell.
See `Based on cell/row` example below.
<Canvas>
  <Story name="Custom Actions">
    {() => {
      const renderFlavor = (cell, row, index) => {
        const rows = [
          { href: cell.href, name: cell.name, id: row.id, index, }
        ];
        const columns = [
          { heading: 'Url', dataKey: 'href', render: (cell) => <a href={cell}>{cell}</a> },
          { heading: 'Name', dataKey: 'name' },
          { heading: 'ID', dataKey: 'id' },
          { heading: 'Index', dataKey: 'index' },
        ];
        return (
          <Table
            columns={columns}
            rows={rows}
            rowKey="id"
            isCompact
          />
        );
      };
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color' },
        { heading: 'Based on the cell/row', dataKey: 'flavor', render: renderFlavor},
        { heading: 'Any custom JSX', render: () => <Button>Do anything</Button> }
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: { name: 'vanilla', href: 'www.vanilla.com' } },
        { id: 2, color: 'blue', flavor: { name: 'chocolate', href: 'www.chocolate.com' } },
        { id: 3, color: 'green', flavor: { name: 'strawberry', href: 'www.strawberry.com' } },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
        />
      );
    }}
  </Story>
</Canvas>

## Empty Cell Placeholder

The empty cell placeholder can be set on a global level as a prop on `<Table />` or individually per column
by adding the `emptyCellPlaceholder` to the column configuration object. In cases where both is set, the column
placeholder takes precedence over the global placeholder. As seen in the example below where the price column uses
`$0.00` as a placeholder where a price is missing.

<Canvas>
  <Story name="Empty Cell Placeholder">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color', emptyCellPlaceholder: '--' },
        { heading: 'Flavor', dataKey: 'flavor' },
        { heading: 'Price', dataKey: 'price', render: (cell) => cell ?`$${cell}` : null, emptyCellPlaceholder: '$0.00'}
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla', price: 10 },
        { id: 2, color: '', flavor: 'chocolate', price: 12.21 },
        { id: 3, color: 'green', flavor: 'strawberry', price: 9.24 },
        { id: 4, color: 'blue', flavor: 'rocky road' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
        />
      );
    }}
  </Story>
</Canvas>


## Borderless

Render a borderless table by passing `isBorderless` (boolean) prop to the table.

<Canvas>
  <Story name="Borderless">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color' },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          isBorderless
        />
      );
    }}
  </Story>
</Canvas>


## Compact

Render a compact table by passing `isCompact` (boolean) prop to the table.

<Canvas>
  <Story name="Compact Cells">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color' },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          isCompact
        />
      );
    }}
  </Story>
</Canvas>

## Striped

Render a striped table to slightly improve readibility by passing `isStriped` (boolean) prop to the table.

<Canvas>
  <Story name="Striped">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color' },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
        { id: 4, color: 'green', flavor: 'strawberry' },
        { id: 5, color: 'green', flavor: 'strawberry' },
        { id: 6, color: 'green', flavor: 'strawberry' },
        { id: 7, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          isStriped
        />
      );
    }}
  </Story>
</Canvas>

## Hover

Make rows 'hoverable' by passing `hoverableRows` (boolean) prop to the table.
<Canvas>
  <Story name="Hoverable Rows">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color' },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          hoverableRows
        />
      );
    }}
  </Story>
</Canvas>

## Striped & Hoverable

You can combine any of these boolean props based on your UI needs.

<Canvas>
  <Story name="Striped and Hoverable Rows">
    {() => {
      const columnConfig = [
        { heading: 'ID', dataKey: 'id' },
        { heading: 'Color', dataKey: 'color' },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          hoverableRows
          isStriped
        />
      );
    }}
  </Story>
</Canvas>

## Aligning Cell Text

Align cell content as needed with the `align` prop. Either pass the prop at the `<Table />` level for all columns, or individually
in a single `Column` object. NOTE: right alignment is best reserved for numerical data display.
We recommend refraining from specific alignment unless it serves the data, as alignment discrepancies in different columns
may interrupt the natural reading flow for a user.

<Canvas>
  <Story name="Aligning Cell Text">
    {() => {
      const columnConfig = [
        { heading: 'Right aligned', dataKey: 'id', align: 'right' },
        { heading: 'Center aligned', dataKey: 'color', align: 'center' },
        { heading: 'Left aligned (default)', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
        />
      );
    }}
  </Story>
</Canvas>

The below is an example of setting the `align` prop globally in the `<Table />` and overwriting its value on a specific column

<Canvas>
  <Story name="Global Align">
    {() => {
      const columnConfig = [
        { heading: 'Center Aligned via Column Config', dataKey: 'id', align: 'center' },
        { heading: 'Globally aligned right', dataKey: 'color' },
        { heading: 'Also globally aligned right', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
          align="right"
        />
      );
    }}
  </Story>
</Canvas>

## Custom Column Classes

You can add custom classes to both your table header cell as well as all the cells in a column by passing the Classes
in the column config.

<Canvas>
  <Story name="Custom Column Classes">
    {() => {
      const columnConfig = [
        { heading: 'with cellClassName', dataKey: 'id', cellClassName: 'background-color-secondary-lightest' },
        { heading: 'With headerClassName', dataKey: 'color', headerClassName: 'background-color-tertiary-lightest' },
        { heading: 'Flavor', dataKey: 'flavor' },
      ];
      const tableData = [
        { id: 1, color: 'red', flavor: 'vanilla' },
        { id: 2, color: 'blue', flavor: 'chocolate' },
        { id: 3, color: 'green', flavor: 'strawberry' },
      ];
      return (
        <Table
          rowKey="id"
          columns={columnConfig}
          rows={tableData}
        />
      );
    }}
  </Story>
</Canvas>
