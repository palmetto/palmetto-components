import { useRef, useState } from 'react';
import { Meta, Story, Canvas, ArgsTable } from '@storybook/addon-docs';
import { Drawer } from './Drawer';
import { Alert } from '../Alert/Alert';
import { Box } from '../Box/Box';
import { Button } from '../Button/Button';
import { TextInput } from '../TextInput/TextInput';
import { RadioGroup } from '../RadioGroup/RadioGroup';

<Meta title="Components/Drawer/Overview" component={Drawer} />

# Drawer

A Drawer is a panel that is typically overlaid on top of a page and slides in from the side. It contains a set of information or actions without leaving the context of the original page. They do not interrupt the a users flow like a modal.

<Canvas isExpanded>
  <Story name="Basic Drawer">
    {() => {
      const [isOpen, setIsOpen] = useState(false);
      const open = () => setIsOpen(true);
      const close = () => setIsOpen(false);
      return (
        <>
          <Button variant="light" onClick={open}>
            Open Drawer
          </Button>
          <Drawer isOpen={isOpen} onDismiss={close}>
            <Box padding="lg" display="block" childGap="md">
              <Button variant="light" onClick={close}>
                Close
              </Button>
              <Box>Drawer content&hellip;</Box>
              <Box>Drawer content&hellip;</Box>
              <Box>Drawer content&hellip;</Box>
            </Box>
          </Drawer>
        </>
      );
    }}
  </Story>
</Canvas>

## Usage Guidelines

- Use the drawer as way to achieve progressive disclosure, to reveal relevant information at the appropriate time.
- The Drawer visibility is controlled via the `isOpen` prop, and is hidden by default. To handle closing the Drawer, provide an `onDismiss` callback that will be called when the user clicks the Overlay or Esc keyboard key.
- When a Drawer is open, the main body is scroll-locked by default.
- Avoid nesting Drawers to prevent usability issues.
- The button that triggers the drawer opening should be in close proximity to the Drawer itself.
- Drawers are appropriate for supplemental information, filters, or subtasks where it's important to keep the subtasks in the context of the main task

### When not to use

- To force users to complete an action before continuing. Use a [Modal](/docs/components-modal-overview--basic-usage) instead.
- For small content or a few options near the original content, use a [Popover](/docs/components-popover-overview--demo).

## Content Guidelines

Drawers are good for short pieces of content that are related to the main screen but not a part of it. Examples include:

- Contextual help
- Notifications or activity log
- Simple forms or settings
- Navigation or page table of contents

## Accessibility

- Use the `ariaLabel` or `ariaLabelledBy` props to properly label a drawer to provide context for users with assistive technology such as screen readers. If a drawer is announced to the user without a label, it can be confusing and difficult to navigate.
- When the Drawer is opened, focus is trapped inside the Drawer.
- 'Esc'
- By default, the Drawer sets focus on the first focusable element. If the `initialFocusRef` prop is passed, the Drawer sets focus on the element with the assigned ref.
- After the drawer closes, focus is returned to the element that triggered it.

## Props

<ArgsTable of={Drawer} />

## Placement

The Drawer can appear from the right (default), left, top, or bottom of the screen. When appearing from the left or right of the screen, the close Icon Button is positioned on the same side where the Drawer originates from. When appearing from the top or bottom of the screen, the close Icon Button is positioned on the right as default.

<Canvas isExpanded>
  <Story name="Placement">
    {() => {
      const [isOpen, setIsOpen] = useState(false);
      const [value, setValue] = useState('right');
      const placementOptions = [
        {
          id: 'top',
          value: 'top',
          label: 'top',
        },
        {
          id: 'right',
          value: 'right',
          label: 'right',
        },
        {
          id: 'bottom',
          value: 'bottom',
          label: 'bottom',
        },
        {
          id: 'left',
          value: 'left',
          label: 'left',
        },
      ];
      const open = () => setIsOpen(true);
      const close = () => setIsOpen(false);
      return (
        <Box display="block" childGap="md">
          <RadioGroup
            title="Placement"
            direction="row"
            name="placement"
            onChange={event => setValue(event.target.value)}
            value={value}
            options={placementOptions}
          />
          <Button variant="light" onClick={open}>
            Open Drawer
          </Button>
          <Drawer isOpen={isOpen} onDismiss={close} placement={value}>
            <Box padding="lg" display="block" childGap="md">
              <Button variant="light" onClick={close}>
                Close
              </Button>
              <Box as="p">drawer content</Box>
              <Box as="p">drawer content</Box>
              <Box as="p">drawer content</Box>
              <Box as="p">drawer content</Box>
              <Box as="p">drawer content</Box>
              <Box as="p">drawer content</Box>
              <Box as="p">drawer content</Box>
              <Box as="p">drawer content</Box>
              <Box as="p">drawer content</Box>
            </Box>
          </Drawer>
        </Box>
      );
    }}
  </Story>
</Canvas>

## Hidden Overlay

In cases where content in the drawer is supplemental to content on the main area of the page, use `hideOverlay` to allow for interaction between the areas (e.g. copy-and-paste text from main area into a form in the drawer).

Note that focus and page scrolling will not be locked if `hideOverlay` is true.

<Canvas isExpanded>
  <Story name="Hidden Overlay">
    {() => {
      const [isOpen, setIsOpen] = useState(false);
      const open = () => setIsOpen(true);
      const close = () => setIsOpen(false);
      return (
        <>
          <Button variant="light" onClick={open}>
            Open Drawer
          </Button>
          <Drawer isOpen={isOpen} onDismiss={close} hideOverlay>
            <Box padding="lg" display="block" childGap="md">
              <Button variant="light" onClick={close}>
                Close
              </Button>
              <Box>drawer content</Box>
            </Box>
          </Drawer>
        </>
      );
    }}
  </Story>
</Canvas>

## Initial Focus Ref

By default the first focusable element will receive focus when the drawer opens, but you can provide a ref to focus instead.

<Alert
  hasIcon
  message="Without the initialFocusRef prop, the drawer will automatically focus on the first focusable element in it's children."
  variant="info"
/>

<Canvas isExpanded>
  <Story name="Initial Focus Ref">
    {() => {
      const [isOpen, setIsOpen] = useState(false);
      const ref = useRef();
      const open = () => setIsOpen(true);
      const close = () => setIsOpen(false);
      return (
        <>
          <Button variant="light" onClick={open}>
            Open Drawer
          </Button>
          <Drawer isOpen={isOpen} onDismiss={close} initialFocusRef={ref}>
            <Box padding="lg" display="block" childGap="md">
              <Button variant="light" onClick={close}>
                Close
              </Button>
              <Box>drawer content</Box>
              <Button variant="dark" isOutlined ref={ref} onClick={close}>
                I receive focus
              </Button>
            </Box>
          </Drawer>
        </>
      );
    }}
  </Story>
</Canvas>

## Contained Drawer

Render the Drawer within a containing div using `containerRef`.

<Alert
  hasIcon
  message="When choosing to use a Drawer within a containing div, use dangerouslyBypassScrollLock to allow the content outside of the containing div to remain interactive."
  variant="info"
/>

<Canvas>
  <Story name="Contained Drawer">
    {() => {
      const containerRef = useRef();
      const [showDrawer, setShowDrawer] = useState(false);
      return (
        <Box
          position="relative"
          display="block"
          height="500px"
          id="myContainer"
          ref={containerRef}
          background="secondary-900"
          padding="lg"
        >
          <Button variant="light" onClick={() => setShowDrawer(true)}>
            Show Drawer
          </Button>
          <Drawer
            isOpen={showDrawer}
            onDismiss={() => setShowDrawer(false)}
            containerRef={containerRef}
            dangerouslyBypassScrollLock
          >
            <Box padding="lg" as="p">
              This drawer is rendered inside it&apos;s containing div, rather than the document.body
            </Box>
          </Drawer>
        </Box>
      );
    }}
  </Story>
</Canvas>
